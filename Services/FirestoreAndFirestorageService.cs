using Firebase.Database;
using Firebase.Database.Query;
using Firebase.Storage;
using InternConnect.Models;

namespace InternConnect.Services
{
    public class FirestoreAndFirestorageService
    {
        private readonly FirebaseStorage _storage;
        private readonly FirebaseClient _database;

        public FirestoreAndFirestorageService()
        {
            // Initialize Firebase Storage
            _storage = new FirebaseStorage("internconnect-fcc92.appspot.com");

            // Initialize Firebase Realtime Database
            _database = new FirebaseClient("https://internconnect-fcc92-default-rtdb.firebaseio.com/");
        }

        // Check if user exists in the Realtime Database
        public async Task<bool> CheckIfUserExistsAsync(string userId)
        {
            string safeEmail = userId.Replace("@", "-").Replace(".", "-");
            var user = await _database
                .Child("users")
                .Child(safeEmail)
                .OnceSingleAsync<ProfileModel>();

            return user != null;
        }

        // Save user profile to Realtime Database
        public async Task SaveUserProfileAsync(ProfileModel profile)
        {
            // Transform the email into a safe Firebase key (replace "@" and "." with "-")
            string safeEmail = profile.Email.Replace("@", "-").Replace(".", "-");

            await _database
                .Child("users")
                .Child(safeEmail)
                .PutAsync(profile);
        }


        public async Task<string> UploadProfileImageAsync(string email, Stream imageStream)
        {
            if (string.IsNullOrEmpty(email) || imageStream == null || imageStream.Length == 0)
            {
                throw new ArgumentException("Email and image stream must not be null or empty.");
            }

            try
            {
                // URL-encode the email to avoid special characters causing issues
                string encodedEmail = Uri.EscapeDataString(email);

                // Determine the extension from the stream content
                string extension = GetFileExtension(imageStream) ?? ".jpg"; // Default to .jpg if unknown

                // Remove leading slashes from the path
                var imagePath = $"profile pictures/{encodedEmail}{extension}";
                var storageReference = _storage.Child(imagePath);

                // Copy the input stream to a MemoryStream to ensure it's seekable
                using (var memoryStream = new MemoryStream())
                {
                    await imageStream.CopyToAsync(memoryStream);
                    memoryStream.Position = 0; // Reset the position of the memory stream

                    // Upload the image using the MemoryStream
                    var uploadResult = await storageReference.PutAsync(memoryStream);
                    if (uploadResult != null)
                    {
                        // Get the download URL from Firebase
                        var imageUrl = await storageReference.GetDownloadUrlAsync();
                        return imageUrl; // Return the URL generated by Firebase
                    }
                    else
                    {
                        throw new Exception("Failed to upload image.");
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error uploading image: {ex.Message}");
                throw;
            }
        }

        // Helper method to detect image extension from stream
        private string? GetFileExtension(Stream stream)
        {
            // You can use a third-party library like SixLabors.ImageSharp or SkiaSharp to detect image format.
            // For demonstration, we'll return ".jpg", ".png", or ".jpeg" based on file signature.

            byte[] buffer = new byte[4];
            stream.Position = 0;
            stream.Read(buffer, 0, buffer.Length);
            stream.Position = 0; // Reset stream position

            // Check file signatures (Magic Numbers) to determine format
            if (buffer[0] == 0xFF && buffer[1] == 0xD8)
                return ".jpg"; // JPEG
            if (buffer[0] == 0x89 && buffer[1] == 0x50)
                return ".png"; // PNG

            return null; // Default case
        }
    }
}
